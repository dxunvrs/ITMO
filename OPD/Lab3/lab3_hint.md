# Нужная информация для третьей лабы (ветвление, адресация и немного ассемблера)

## Команды
Есть 4 вида команд: безадресные, ввода-вывода, адресные и ветвления.  
У каждой команды есть несколько циклов выполнения:
1. Цикл выборки команды (Instruction Fetch, IF)
2. Цикл выборки адреса (Address Fetch, AF)
3. Цикл выборки операнда (Operand Fetch, OF)
4. Цикл исполнения (Execution, EX)
5. Цикл прерывания (Interruption, INT)

Для безадресных и адресных команд есть файл с предыдущей лабы. (будет обновляться) ВАЖНО: в предыдущем файле OF и AF для абсолютной адресации

## Команды ветвления:
Начинаются с буквы F  
- IF:
    1. IP -> BR, AR
    2. BR + 1 -> IP; MEM(AR) -> DR
    3. DR -> CR
- AF: отсутствует
- OF: отсутствует

Установка флагов для всех команд ветвления одинаковая:  
NZVC: ----

В мнемонике будет D - смещение(знаковое!), на него получается 8 бит, а значит -2^7 <= D <= 2^7-1  
-128 <= D <= 127
### BEQ D - F0XX
BEQ - branch if equals - переход, если равенство  
Проверяет флаг Z 
IF Z==1 THEN IP+D+1 -> IP

- EX: 
    1. если PS(Z) = 0, то все - прерывание, иначе:
    2. extend sign CR(0..7) -> BR
    3. BR + IP -> IP

### BNE D - F1XX
BNE - branch if not equals - переход, если неравенство  
Также проверяет флаг Z  
IF Z==0 THEN IP+D+1 -> IP

- EX:
    1. если PS(Z) = 1, то прерывание, иначе:
    2. extend sign CR(0..7) -> BR
    3. BR + IP -> IP

### BMI D - F2XX
BMI - branch if minus - переход, если минус  
Проверяет флаг N  
ВАЖНО: для БЭВМ 0 - это положительное число, соответсвенно флаг NF=0 
IF N==1 THEN IP+D+1 -> IP

- EX:
    1. если PS(N) = 0, то прерывание, иначе:
    2. extend sign CR(0..7) -> BR
    3. BR + IP -> IP

### BPL D - F3XX
BPL - branch if plus - переход, если плюс  
Также проверяет флаг N  
ВАЖНО: для БЭВМ 0 - это положительное число, соответсвенно флаг NF=0  
IF N==0 THEN IP+D+1 -> IP

- EX:
    1. если PS(N) = 1, то прерываниеб иначе:
    2. extend sign CR(0..7) -> BR
    3. BR + IP -> IP

### BCS D / BHIS D - F4XX
Имеет две мнемоники для разных случаев, придумано исключительно для удобства чтения другими человеками  

BCS - branch if carry set - переход, если перенос  
Здесь речь про знаковую арифметику, просто проверка на CF. Как пример, проверка CF после какого-нибудь сдвига

BHIS - branch if higher or same - переход, если выше или равно  
Здесь речь про беззнаковую арифметику  

- EX:
    1. если PS(C) = 0, то прерывание, иначе:
    2. extend sign CR(0..7) -> BR
    3. BR + IP -> IP

**Объяснение**:  
В беззнаковой арифметике флаг CF выполняет роль переполнения(OF). Итак берем два числа: A и B. Допустим мы использовали CMP (пусть A было в аккумуляторе)  
Тогда CMP установило флаги по A + ~B + 1  
А теперь вспомним, что доп.код это 2^n-B (для двоичной сс)  
(2^n - 1 - B) + 1 --- Первая скобка это наша инверсия (просто напоминание из первого семестра)  
Значит флаги ставились по A + 2^n - B = S - обозначим для удобства  
Осталось разобрать случаи:  
1. A >= B  
Тогда A-B >= 0, то есть S - 2^n  >= 0  
S >= 2^n  
А максимум сколько? 2^n-1. Следовательно, переполнение и CF=1   
2. A < B  
Тогда A-B < 0, то есть S - 2^n < 0  
S < 2^n и переполнения нет, CF = 0

### BCC / BLO D - F5XX
Аналогично две мнемоники и проверка CF

BCC (для знаковой) - branch if carry clear - переход, если нет переноса  
BLO (для беззнаковой) - branch if lower - переход, если меньше

- EX: 
    1. если PS(C) = 1, то прерывание, иначе:
    2. extend sign CR(0..7) -> BR
    3. BR + IP -> IP

### BVS D - F6XX
BVS - branch if overflow set - переход, если переполнение  
Проверяет флаг OF  
ВАЖНО: для суждения о том, больше ли число получилось или нет, флага OF не достаточно

- EX:
    1. если PS(V) = 0, то прерывание, иначе:
    2. extend sign CR(0..7) -> BR
    3. BR + IP -> IP

### BVC D - F7XX
BVC - branch if overflow clear - переход, если переполнения нет  
Проверяет флаг OF

- EX:
    1. если PS(V) = 1, то прерывание, иначе:
    2. extend sign CR(0..7) -> BR
    3. BR + IP -> IP

### BLT D - F8XX
BLT - branch if less than - переход, если меньше  
Теперь это сравнение знаковых чисел, проверяет N+V (mod 2)  
То есть 0, если N=V, и 1 - если N!=V  

- EX:
    1. если PS(N) = 0, то идем делать BVS, иначе BVC

Если N+V = 1(mod 2), то A было меньше B  
Если N+V = 0(mod 2), то A было больше или равно B  
**Объяснение**:  
Не будем использовать умные идеи(втшники все-таки), поэтому в тупую переберем случаи:
1. Пусть A и B одного знака (все также будет считать, что A - в аккумуляторе и было CMP для B)  
Делали A-B = A + (-B). A и -B разных знаков, а при сложении чисел разных знаков переполнения никогда не будет, значит V=0  
    - Пусть A > =B, тогда A-B >= 0 и флаг N=0  
    Итого N+V=0+0=0 (mod 2) и действительно A >= B
    - Пусть A < B, тогда A-B < 0 и флаг N=1  
    Итого N+V=1+0=1 (mod 2) и действительно A < B
2. Пусть A и B разных знаков, причем переполнения не было  
Тогда флаг NF сработает корректно  
N=1 => A < B и при этом N+V=1+0=1 (mod 2)  
N=0 => A >= B и при этом N+V=0+0=0 (mod 2)
3. Пусть A и B разных знаков, причем было переполнение  
Раз было переполнение, то знак результата инвертирован, по сравнению с истиным результатом  
N=1 => A >= B и при этом N+V=1+1=0 (mod 2)  
N=0 => A < B и при этом N+V=0+1=1 (mod 2)  

Корректность доказана

### BGE D - F9XX
BGE - branch if grater or equal - переход, если больше или равно  
Также смотрит N+V (mod 2)  

- EX:
    1. если PS(N) = 0, то идем делать BVC, иначе BVS

### FAXX - резерв

## Адресация:
Существует несколько видов адресации, которые определяют OF и AF адресных команд

### Прямая абсолютная адресация 
|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|0|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|?|?|?|?|**0**|x|x|x|x|x|x|x|x|x|x|x|x|x|x|

11 бит - 0  
Тогда первые(с конца) 11 битов означают непосредственный адрес, откуда загружать  
(напомним, что 2^11=2048 вариантов, а значит и ячеек памяти)

Мнемоника ADD 0ADDR или ADD $L

- AF: отсуствует
- OF:
    1. DR -> AR; MEM(AR) -> DR

### Прямая относительная адресация
|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|0|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|?|?|?|?|**1**|**1**|**1**|**0**|x|x|x|x|x|x|x|x|x|x|x|

То есть вторая(с начала) буква в команде - E  
В битах 0-7 закодировано смещение относительно адреса следующей команды. Что это значит?  
В IF мы уже увеличили IP на 1, а значит, смещение отсчитывается не с текущей ячейки а с следующей.  
Для смещения здесь, как и для случая с командами ветвления, отведено 8 бит, а это значит, что смещение лежит на отрезке [-128,127]

Мнемоника ADD L или ADD (IP+N)

- AF:
    1. SXT_CR(0..7) -> BR - расширение знака
    2. BR + IP -> DR
- OF:
    1. DR -> AR; MEM(AR) -> DR

Нужно быть внимательным, так как идет расширение знака и суммирование в случае с отрицательным сдвигом может быть не очевидным

### Косвенная относительная адресация
|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|0|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|?|?|?|?|**1**|**0**|**0**|**0**|x|x|x|x|x|x|x|x|x|x|x|

Вторая(с начала) цифра - 8
В битах 0-7 закодировано смещение относительно адреса следующей команды. После смещения мы попадаем в ячейку, значение которой - адрес нашего операнда.
Запутанно, но это нужно для перебора массивов, на примерах станет понятнее.

Мнемоника ADD (L)

- AF:
    1. SXT_CR(0..7) -> BR
    2. BR + IP -> AR, MEM(AR) -> DR
- OF:
    1. DR -> AR; MEM(AR) -> DR

### Косвенная автоинкрементная адресация(постинкремент)
|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|0|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|?|?|?|?|**1**|**0**|**1**|**0**|x|x|x|x|x|x|x|x|x|x|x|

Вторая(с начала) буква - A  
Таже косвенная адресация, только теперь в конце мы дополнительно увеличиваем значение ячейки, куда привело нас смещение на 1 (то есть адрес операнда).  
Такая адресация нужна для обхода массива с первого элемента.

Мнемоника ADD (L)+

- AF:
    1. SXT_CR(0..7) -> BR
    2. BR + IP -> AR, MEM(AR) -> DR, DR + 1 -> DR
    3. DR -> MEM(AR), DR - 1 -> DR
- OF:
    1. DR -> AR; MEM(AR) -> DR

### Косвенная автодекрементная адресация(предекремент)
|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|0|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|?|?|?|?|**1**|**0**|**1**|**1**|x|x|x|x|x|x|x|x|x|x|x|

Вторая(с начала) буква - B  
Таже косвенная адресация, только сначала мы уменьшаем адрес операнда на 1.  
Такая адресация нужна для обхода массива с последнего элемента.

Мнемоника ADD -(L)

- AF:
    1. SXT_CR(0..7) -> BR
    2. BR + IP -> AR, MEM(AR) -> DR, DR - 1 -> DR
    3. DR -> MEM(AR)
- OF:
    1. DR -> AR; MEM(AR) -> DR

### Прямая загрузка
|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|0|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|?|?|?|?|**1**|**1**|**1**|**1**|x|x|x|x|x|x|x|x|x|x|x|

Вторая(с начала) буква - F  
Значение из битов 0..7 непосредственно загружается, при этом происходит расширение знака для корректности всех операций

Мнемоника ADD #N

- AF:
    1. SXT_CR(0..7) -> BR, BR -> DR
- OF: -

### Некий важный момент
Были пропуски, так вот:  
1001(9) - резерв  
1100(C) - косвенная относительно SP (вроде не надо в этой лабе)  
1101(D) - резерв

## Небольшой мануал по ассемблеру БЭВМ
Что в нем есть?

### Ключевые слова: org, start
org - указывает на ячейку памяти куда записать
Например, org 0x5D8 в начале программы укажет, где записывать значения  
start - метка, указывающая на начало исполнения(в задании лабы это плюсик)  

### Свои метки
Можно делать свои метки, синтаксис  
[название]: значение  
В качестве значений(то что знаю) можно использовать WORD и $  
Также метка может быть просто указателем на какой-то блок команд  
Например:
```
; комментарий кстати ставиться точкой с запятой
A: WORD 0xFFFF ; наша метка-константа
B: $x1 ; метка, указывает на АДРЕС ячейки
start: LD A
prog: ADD B
ADD A
JUMP prog ; вернет в prog
HLT
x1: WORD 0x0000
```
ВНИМАНИЕ: Программа выше носит демонстрационный характер, не пытайтесь запустить ее на БЭВМ

### Адресация
Абсолютная через $  
Прямая загрузка через #  
Прямая относительная только через метки(типо ip+2 писать нельзя, а вот со стеком можно, уточню в следующей лабе)  
Косвенная относительная (var) или (0x5D8)  
С постинкрементом (var)+  
С предекрементом -(var)

### Советую ознакомиться с моей [программой](https://github.com/dxunvrs/ITMO/blob/master/OPD/Lab3/program.asm) обхода массива

### Трассировка
Пишем нашу asm программу, запускаем БЭВМ следующим образом:
```
java -jar -Dmode=dual -Dcode=program.asm bcomp-ng.jar
```
В БЭВМ жмем кнопку ПРОДОЛЖИТЬ и ловим значения в консоли